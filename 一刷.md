# 代码随想录一刷 时间 ： 2.20 - 3.26

[代码随想录](https://programmercarl.com/)

## 1、数组

###  1.1 二分查找

[704.二分查找](https://leetcode-cn.com/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

思路：当题目出现了数组时，且注意说了**有序**，提示里面也说了**不重复**，那么就应该想到二分查找



```java
class Solution {
    public int search(int[] nums, int target) {
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}
```



### 1.2 移除元素

[27.移除元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

思路：

快慢指针，一次循环就能替代俩次循环，**很多考察数组、链表、字符串等操作的面试题，都可以使用双指针法**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0;
        int slow;
        for (slow = 0; fast < nums.length; fast++) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }   
}
```



[26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

思路：

也是使用快慢指针，只是这题的快慢指针稍作调整即可

```java
class Solution {
    public int removeDuplicates(int[] nums) {
      int slow;
      int fast = 1;
      for (slow = 0; fast < nums.length; fast++) {
          if (nums[slow] != nums[fast]) {
            slow++;
            nums[slow] = nums[fast];
          }
      }
      return slow + 1;
    }
}
```

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作

注意：这里定义交换函数**不可以使用异或**达到交换，因为可能会存在如下案例

输入：[1,0]

输出：[0,0]

预期结果：[1,0]

在我的方法中可能会出现==slow == fast== 的情况

顾连续俩次异或会导致数字清零的现象！！！！

```java
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums.length == 1) {
            return;
        }
        int slow;
        int fast = 0;
        for (slow = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
               swap(nums,slow,fast);
                slow++;
            }
        }
    }
    public void swap(int[] arr,int slow,int fast) {
        int temp = arr[slow];
        arr[slow] = arr[fast];
        arr[fast] = temp;
    }
}
```



### 1.3 有序数组的平方

[977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

方法一：如果是按照我这样做就没意义了，试着不要调用库试试！！！

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            nums[i] *= nums[i];
        }
        Arrays.sort(nums);
        return nums;
    }
}
```

方法二：使用双指针，因为题目说了其实就是一个有序数组，只是说平方后可能会出现乱序，但是每次比较**最大值肯定出现**

**在数组的俩端**，故我们的双指针需要放在数组的俩端

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        int[] res = new int[nums.length];
        int index = nums.length - 1;
        while(left <= right) {
            if (nums[left] * nums[left] <= nums[right] * nums[right]) {
                res[index--] = nums[right] * nums[right];
                --right;
            } else {
                res[index--] = nums[left] * nums[left];
                ++left;
            }
        }
        return res;
    }
}
```



### 1.4 长度最小的子数组

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

思路：

使用**滑动窗口**来解决，

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

滑动窗口的实现原理也是使用双指针

注意：时间复杂度为O(n)，空间复杂度为O(1)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int result = Integer.MAX_VALUE;
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while(sum >= target) {
                result = Math.min(result, right - left + 1);
                sum -= nums[left++]; 
            }
        }
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```



### 1.5 螺旋矩阵Ⅱ

[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 n ^ 2 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix`

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        // 循环次数
        int loop = n / 2;
        // 定义每次循环起始位置
        int startX = 0;
        int startY = 0;
        // 定义偏移量
        int offset = 1;
        // 定义填充数字
        int count = 1;
        // 定义中间位置
        int mid = n / 2;
        while (loop > 0) {
            int i = startX;
            int j = startY;
            // 模拟上侧从左到右
            for (; j<startY + n -offset; ++j) {
                res[startX][j] = count++;
            }
            // 模拟右侧从上到下
            for (; i<startX + n -offset; ++i) {
                res[i][j] = count++;
            }
            // 模拟下侧从右到左
            for (; j > startY; j--) {
                res[i][j] = count++;
            }
            // 模拟左侧从下到上
            for (; i > startX; i--) {
                res[i][j] = count++;
            }
            loop--;
            startX += 1;
            startY += 1;
            offset += 2;
        }
        if (n % 2 == 1) {
            res[mid][mid] = count;
        }
        return res;
    }
}

```



## 2、链表

 ### 2.1 移除链表元素

[203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点**

思路：

考察的其实就是链表的删除操作，无非就是将前一个节点的next指向当前节点的next，但头节点没有前一个节点，故可以设置一个		

**虚拟头节点**来达到删除的效果！

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }
        ListNode dumy = new ListNode(-1,head);
        ListNode pre = dumy;
        ListNode cur = head;
        while(cur != null) {
            if (cur.val != val) {
                pre = cur;
            } else {
                pre.next = cur.next;
            }
            cur = cur.next;
        }
        return dumy.next; 
    }
}
```



### 2.2 设计链表

[707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)

思路：主要是考察链表的基本操作，通过模拟链表加深自己对链表的熟悉

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val) {
        this.val = val;
    }
}
class MyLinkedList {
    int size;
    ListNode head;

    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }
    
    public int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        } 
        ListNode curNode = head;
        for (int i = 0; i <= index; i++) {
            curNode = curNode.next;
        }
        return curNode.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    
    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        size++;
        ListNode preNode = head;
        for (int i = 0; i < index; i++) {
            preNode = preNode.next;
        }
        ListNode addNode = new ListNode(val);
        addNode.next = preNode.next;
        preNode.next = addNode;
    }
    
    public void deleteAtIndex(int index) {
        if (index >= size || index < 0) {
            return;
        }
        size--;
        ListNode preNode = head;
        for (int i = 0; i < index; i++) {
            preNode = preNode.next;
        }
        preNode.next = preNode.next.next;
    }
}
```



### 2.3  反转链表

[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表

思路：

用到的是双指针的思想，定义一个cur节点指向head，定义一个pre节点，初始化为null

再定义一个temp临时保存cur的next节点，因为cur.next会发生变化

接下来就是走交换过程了

```java
class Solution {
    public ListNode reverseList(ListNode head) {
       ListNode pre = null;
       ListNode cur = head;
       ListNode temp = null;
        while(cur != null) {
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```



### 2.4 俩俩交换链表中的节点

[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题

思路：

这道题通过画图来理解它交换的思路

![](D:\Typoramd\java学习笔记\photo\屏幕截图 2022-02-22 203752.png)

搞懂了上面的原理，就可以开始写代码了

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        //定义一个虚拟节点便于交换
        ListNode dump = new ListNode(0);
        dump.next = head;
        ListNode pre = dump;
        while (pre.next != null && pre.next.next != null) {
            ListNode temp = head.next.next;
            pre.next = head.next;
            pre.next.next = head;
            head.next = temp;
            pre = head;
            head = head.next;
        }
        return dump.next;
    }
}
```



### 2.5 删除链表的倒数第N个节点

[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

思路：

双指针的应用，只要将slow和fast俩个指针相差n就行（当然删除节点还需要前一个节点），所以需要pre节点来记录

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
       ListNode dumy = new ListNode(0,head);
       ListNode fast = dumy;
       ListNode slow = dumy;
       while(n-- > 0) {
           fast = fast.next;
       }
       ListNode pre = null;
       while(fast != null) {
           pre = slow; //最后出去的时候为要删除节点的前一个
           slow = slow.next; //slow为要删除的节点
           fast = fast.next; 
       }
       pre.next = slow.next;
       slow.next = null; //将slow节点删除
       return dumy.next;
    }
}
```



### 2.6 链表相交

[面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

注意题目是讲的节点相等而不是值相等，先比较俩个链表的大小，然后长的链表先减到和短链表一样

然后在开始比较是否相等即可。

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
      ListNode curA = headA;
      ListNode curB = headB;
      int lenA = 0;
      int lenB = 0;
      while(curA != null) { //记录链表A的长度
          lenA++;
          curA = curA.next;
      }  
      while(curB != null) { //记录链表B的长度
          lenB++;
          curB = curB.next;
      }
      curA = headA; 
      curB = headB;
        if(lenB > lenA) { // 确保链表A是最长，这样做可以减少比较的次数
            int temp = lenA;
            lenA = lenB;
            lenB = temp;
            ListNode tempNode = curA;
            curA = curB;
            curB = tempNode;
        }
        int dis = lenA - lenB;
        while(dis-- > 0) {
            curA = curA.next; //让链表A达到和B一样的长再做比较
        }

        while(curA != null) {
            if(curA == curB) {
                return curA;
            }
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }
}
```



### 2.7 环形链表Ⅱ

[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

思路：

要解决俩个问题：①是否有环？②入口在哪？

解决：①快慢指针，快指针走俩步，慢指针走一步，若相遇则有环，否则无环

②当相遇的时候，一个指针指向头节点，一个指向相遇的节点，都开始一步步走，相遇既是入口！

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == slow) {
                ListNode index1 = fast;
                ListNode index2 = head;
                while(index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
         return null;
    }
}
```



## 3、哈希表

### 3.1 有效的字母异位词

[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

思路：

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**

这道题目，判断俩个字母是否为字母异位词，数组就是一个简单的哈希表，这里创建一个数组，长度只需要26

就行，值用来记录字符串中字符出现的次数，下标通过每个字符与‘a' 相减得到，最后通过判断数组是否还有不为0的值即可

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] record = new int[26];
        for(char c : s.toCharArray()) {
            record[c - 'a'] += 1;
        }
        for(char c: t.toCharArray()) {
            record[c - 'a'] -= 1;
        }
        for(int i : record) {
            if (i != 0) {
                return false;
            }
        }
        return true;
    }
}
```



### 3.2 俩个数组的交集

[349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

思路：

当涉及到**无序**，**去重**俩个关键字的时候，可以考虑使用set集合，通常使用到hash表解决问题的时候

往往都是牺牲空间换时间，无奈之举

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
      if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length ==0){
          return new int[0];
      }
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        for (int i = 0; i < nums1.length; i++) {
            set1.add(nums1[i]);
        }
        for(int i : nums2) {
            if (set1.contains(i)) {
                resSet.add(i);
            }
        }
        int[] res = new int[resSet.size()];
        int index = 0;
        for (int i : resSet) {
            res[index++] = i;
        }
        return res;
    }
}
```



### 3.3 快乐数

[202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

思路：

题目中说到俩个要点需要注意：①可能**无限循环**，②**结果为1**就是快乐数

解决：①通过set集合记录每次产生的数，若有重复的出现则判断为false

②第二个要解决的就是取数问题了，直接写代码就行了

```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while(n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);           
        }
        return n == 1;
    }

    public int getNextNumber(int n) {
        int res = 0;
        while(n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
}
```



### 3.4 俩数之和

[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

思路：

在前面我们用了**数组**解决字母异位词，但是存在缺陷的就是数组的大小是限制的，如果哈希值太大，则会造成很大的空间浪费

**set集合**解决俩个数组的交集和快乐数，但是set集合的特点是只有一个key，此题需要比较值且返回下标，不是很匹配

则在这里我们需要使用**map集合**，特点就是key-value存储，非常适合本题的条件！

一次循环遍历，将每个数都和target做差，再拿差值比较是否在map中出现，若有出现，则返回下标

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
       int[] res = new int[2];
       Map<Integer,Integer> map = new HashMap<>();
       for (int i = 0; i < nums.length; i++) {
           int temp = target -nums[i];
           if (map.containsKey(temp)) {
               res[1] = i;
               res[0] = map.get(temp);
           }
           map.put(nums[i], i);
       }
       return res;
    }
}
```



### 3.5 四数相加Ⅱ

[454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

思路：

使用map集合，遍历前俩个数组，将得到的和作为key，出现的次数作为value

再遍历后俩个数组，若有相同的和出现，则把对应的value加进来

最后返回次数

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer,Integer> map = new HashMap<>();
        int temp = 0;
        int res = 0;
        for (int i : nums1) {
            for (int j : nums2) {
                temp = i + j;
                if (map.containsKey(temp)) {
                    map.put(temp, map.get(temp) + 1);
                } else {
                    map.put(temp, 1);
                }
            }
        }
        for (int i : nums3) {
            for(int j : nums4) {
                temp = i + j;
                if (map.containsKey(0 - temp)) { //因为要想变成0，前面俩个数相加的结果和后面俩数相加的结果必须要为相反数
                    res += map.get(0 - temp);
                }
            }
        }
        return res;
    }
}
```



### 3.6 赎金信

[383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

思路：

刚看到这题我想的是直接用map解决，但是没考虑到**使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！**

解题思路和字母异位词挺像的,如果是记录**字母**且都是**小写**出现的次数，就应该想到用**数组做哈希表**去解决问题

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] record = new int[26];
        int temp;
        for (int i = 0; i < magazine.length(); i++) {
            temp = magazine.charAt(i) - 'a';
            record[temp]++;
        }
        for (int i = 0; i < ransomNote.length(); i++) {
            temp = ransomNote.charAt(i) - 'a';
            if (record[temp] > 0) {
                record[temp]--;
            } else {
                return false;
            }
        }
        return true;
    }
}
```



### 3.7 三数之和

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

思路：

这道题目比较复杂，复杂在题目中说了不能有重复的三元组

用的解法是双指针，没有用哈希表，因为去重的细节比较麻烦

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums); // 做这类题，先排好序，这是前提
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {//若第一个元素就为正数，在排好序的数组中那就没必要继续遍历了，后续不可能存在三元组相加0的情况
                return result;
            }
            if (i > 0 && nums[i] == nums[i - 1]) { //去重，去除因为nums[i]可能导致的重复
                continue;
            }
            int left = i + 1;
            int right = nums.length - 1;
            while (right > left) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    while (right > left && nums[right] == nums[right - 1]) right--;//去重，去除因为nums[right]可能导致的重复
                    while (right > left && nums[left] == nums[left + 1]) left++;//去重，去除因为nums[left]可能导致的重复
                    left++;
                    right--;
                }
            }
        }
        return result;
    }
}
```



### 3.8 四数之和

[18. 四数之和](https://leetcode-cn.com/problems/4sum/)

思路：

总的解法大致上是和三数之和是一样的，就是要多加一层for循环，整体去重过程是没有发生变化的

麻烦就麻烦在去重，解题方法就是双指针，然后四元组的数加总和target比较

多出一层for循环的原因就是要多标记一个数，四数嘛

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            for (int k = i + 1; k < nums.length; k++) {
                if (k > i + 1 && nums[k] == nums[k - 1]) {
                    continue;
                }
                int left = k + 1;
                int right = nums.length - 1;
                while(right > left) {
                    // -109 <= nums[i] <= 109 这是题目给的范围
                    // 如果是拿四数相加可能会导致整数溢出的现象，故有以下表达式
                    if (nums[i] + nums[k] > target - nums[left] - nums[right]) {
                        right--;
                    } else if(nums[i] + nums[k] < target - nums[left] - nums[right]) {
                        left++;
                    } else {
                        result.add(Arrays.asList(nums[i],nums[k],nums[left],nums[right]));
                        while(right > left && nums[right] == nums[right-1]) right--;
                        while(right > left && nums[left] == nums[left+1]) left++;
                        left++;
                        right--; 
                    }
                }
            }
        }
        return result;
    }
}
```



### 3.9 总结

> **哈希表分类解题可能会用到如下数据结构**

1. 数组作哈希表（小写字母，记录次数）
2. set集合（无序且不重复）
3. map集合（key-value）

哈希表虽好，但是是**牺牲空间换时间**的策略，解决数组链表的时候也别忘了**双指针**



## 4、字符串

### 4.1 反转字符串

[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

思路：

题目说原地反转，空间复杂度为O(1)，不要调用库方法解决问题，没有意义

这里使用双指针，解决问题soso的

```java
class Solution {
    public void reverseString(char[] s) {
        if (s.length <= 1) {
            return;
        }
        int left = 0;
        int right = s.length - 1;
        while (left < right) {
            mySwap(s, left, right);
            left++;
            right--;
        }
    }
    public void mySwap(char[] arr, int a, int b) {
        char temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```



### 4.2 反转字符串Ⅱ

[541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

思路：

这道题整体上解法还是和反转字符串相似的，主要要解决的就是部分逻辑（2k前k个反转）

当存在规律处理字符串时，可以考虑在for循环上做手脚，

具体看代码

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] res = s.toCharArray();    
        for (int i = 0; i < res.length; i += 2 * k) { // 解决每次加2k的问题
            int start = i;
            int end = Math.min(res.length - 1, start + k - 1); // 反转前k个，通过和数组长度比较，防止下标越界
            while (start < end) {
                res[start] ^= res[end];
                res[end] ^= res[start];
                res[start] ^= res[end];
                start++;
                end--;
            }
        }
        return new String(res);
    }
}
```



### 4.3 替换空格

[剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

思路：

双指针yyds！先遍历一遍字符串，创建一个StringBuilder，每遇到一个空格就加双倍的空格到StringBuilder中，

最后加到字符串中，然后用双指针，一个指向扩容前的字符串末尾，一个指向扩容后的末尾，然后遇到空格，替换相应的字符即可

从后往前的好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。

```java
class Solution {
    public String replaceSpace(String s) {
       StringBuilder sb = new StringBuilder();
       for (int i = 0; i < s.length(); i++) {
           if (s.charAt(i) == ' ') {
               sb.append("  ");
           }
       }
       if (sb.length() == 0){
           return s;
       }
       int left = s.length() - 1;
       s += sb.toString();
       int right = s.length() - 1;
       char[] chars = s.toCharArray();
       while(left >= 0) {
           if (chars[left] == ' ') {
               chars[right--] = '0';
               chars[right--] = '2';
               chars[right] = '%';
           } else {
               chars[right] = chars[left];
           }
           left--;
           right--;
       }
       return new String(chars);
    }
}
```



### 4.4 翻转字符串里的单词

[151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

思路：

①首先去除首位空白

②去除中间多余的空白

③将整个字符串反转

④再依次反转单个单词

总：俩次反转解决了翻转字符串里的单词，其中也用到了双指针的思想

```java
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = removeSpace(s);
        reverseString(sb, 0, sb.length() - 1);
        reverseWord(sb);
        return sb.toString();
    }

    public StringBuilder removeSpace(String s) { //移除首尾空白和中间多余的空白
        int start = 0;
        int end = s.length() - 1;
        while(s.charAt(start) == ' ') start++; //移除首空百
        while(s.charAt(end) == ' ') end--; //移除尾空白
        StringBuilder sb = new StringBuilder();
        while(start <= end) {
            char temp = s.charAt(start);
            if (temp !=' ' || sb.charAt(sb.length() - 1) != ' ') { //移除多余空白，注意后面的的判断条件是去除多余的空白
                sb.append(temp);
            }
            start++;
        }
        return sb;
    }

    public void reverseString(StringBuilder sb, int start, int end) { //反转整个字符串
        while(start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
        }
    }

    public void reverseWord(StringBuilder sb) {// 反转一个单词
        int start = 0;
        int end = 1;
        int n = sb.length();
        while(start < n) {
            while(end < n && sb.charAt(end) != ' ') {  //找到单词的空白间隔
                end++;
            }
            reverseString(sb, start, end - 1);
            start = end + 1;
            end = start + 1;
        }
    }
}
```



### 4.5 左旋转字符串

[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

解法一：

创建一个StringBuilder用来记录，题目说了将前几个指定的元素旋转到尾部

那我就先把后几个元素添加到Stringbuilder中，然后再将前几个加入尾部

时间复杂度为O(n)

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        StringBuilder sb = new StringBuilder();
        for (int i = n;i < s.length(); i++) {
            sb.append(s.charAt(i));
        }
        for (int i = 0; i <= n - 1; i++) {
            sb.append(s.charAt(i));
        }
        return sb.toString();
    }
}
```

解法二：

依然可以和上题一样，这次是先反转局部，再发转整体，从而达到解决问题

是不是很妙

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
       StringBuilder sb = new StringBuilder(s);
       reverseString(sb, 0, n - 1);
       reverseString(sb, n, s.length() - 1);
       return sb.reverse().toString();
    }
    public void reverseString(StringBuilder sb, int start, int end) {
        while(start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
        }
    }
}
```



### 4.6 实现strStr()

[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

思路：

KMP算法，就是用来解决**字符串匹配**问题的，搞懂KMP就需要明白俩点，①什么是前缀表（next[]），②如何得到前缀表

前缀：从首字符开始不包括尾字符的字符串

后缀：从尾字符开始不包括首字符的字符串

①前缀表每一项记录的都是当前字符串的**最长相等前后缀**

②想要得到前缀表就需要知道一点，遇到冲突，就回退

遵循四步：

1. next[]初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况
4. 给对应的next[]赋值

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length() == 0) return 0;
        int[] next = new int[needle.length()];
        getNext(next, needle);
        int j = 0;
        for(int i = 0; i < haystack.length(); i++) {
            while (j > 0 && haystack.charAt(i) != needle.charAt(j)) {
                j = next[j-1];
            }
            if (haystack.charAt(i) == needle.charAt(j)) {
                j++;
            }
            if (j == needle.length()) {
                return (i - needle.length() + 1) ;
            }
        }
        return -1;
    }
    public void getNext(int[] next, String s) { //创建对应的next[]
        //next[]初始化
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.length(); i++) {
            while(j > 0 && s.charAt(j) != s.charAt(i)) { //处理前后缀不相同的情况，用while是因为可能不止回退一步
                j = next[j-1];
            }
            if(s.charAt(i) == s.charAt(j)) { //处理前后缀相同的情况
                j++;
            }
            next[i] = j; //给next[]赋值
        }
    }
}
```



### 4.7 重复的子字符串



## 5、双指针法

### 5.1 移除元素

前面做过了就不放链接和思路了

```java
class Solution {
    public int removeElement(int[] nums, int val) {
     int slow = 0;
     for (int fast = 0; fast < nums.length; fast++) {
         if (nums[fast] != val) {
             nums[slow] = nums[fast];
             slow++;
            } 
        }
        return slow;
    }   
}
```



### 5.2 反转字符串

前面做过，再过一遍会做即可

```java
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length - 1;
        while (left < right) {
            s[left] ^= s[right];
            s[right] ^= s[left];
            s[left] ^= s[right];
            left++;
            right--;
        }
    }
}
```



### 5.3 替换空格

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == ' ') {
                sb.append("  ");
            }
        }
        if (sb.length() == 0) { 
            return s;
        }
        int left = s.length() - 1;
        s += sb.toString();
        int right = s.length() - 1;
        char[] chars = s.toCharArray();
        while (left >= 0) {
            if (chars[left] == ' ') {
                chars[right--] = '0';
                chars[right--] = '2';
                chars[right] = '%';
            } else {
                chars[right] = chars[left];
            }
            right--;
            left--;
        }
        return new String(chars);
    }
}
```



### 5.4 翻转字符串里的单词

思路：

前俩天做的，大概的解题技巧我记得

就是具体代码实现的时候还是有点忘了，还是要多敲多练

解题步骤：

1. 先去除多余的空白（包括内外的）
2. 反转整个字符串
3. 依次反转单个单词

反转先整体再局部，通过俩次反转达到解题

[151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

```java
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = removeSpace(s);
        reverseString(sb, 0, sb.length() - 1);
        reverseEachWord(sb);
        return sb.toString();
    }

    public StringBuilder removeSpace(String s) {
        int start = 0;
        int end = s.length() - 1;
        while(s.charAt(start) == ' ') start++;
        while(s.charAt(end) == ' ') end--;
        StringBuilder sb = new StringBuilder();
        while (start <= end) {
            char temp = s.charAt(start);
            if (temp != ' ' || sb.charAt(sb.length() - 1) != ' ') {
                sb.append(temp);
            }
            start++;
        }
        return sb;
    }

    public void reverseString(StringBuilder sb, int start, int end) {
        while(start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--; 
        }
    }

    public void reverseEachWord(StringBuilder sb) {
        int start = 0;
        int end = 1;
        int n = sb.length();
        while(start < n) {
            while(end < n && sb.charAt(end) != ' ') {
                end++;
            }
            reverseString(sb, start, end - 1);
            start = end + 1;
            end = start + 1;
        }
    }
}
```



### 5.5 反转链表

[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp = null;
        while(cur != null) {
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```



### 5.6 删除链表的倒数第N个结点

[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
      ListNode dumy = new ListNode(0,head);
      ListNode slow = dumy;
      ListNode fast = dumy;
      while(n-- > 0) {
          fast = fast.next;
      }
      ListNode pre = null;
      while(fast != null) { //循环结束后slow指向的是待删除的节点，pre则是前一个节点
          pre = slow;
          slow = slow.next;
          fast = fast.next;
      }
      pre.next = slow.next; //删除节点操作
      slow.next = null;
      return dumy.next;
    }
}
```



### 5.7 链表相交

[面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

思路：

判断的是指针是否相等，不是对应的值是否相等，不要被搞混了

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
     int lenA = 0;
     int lenB = 0;
     ListNode curA = headA;
     ListNode curB = headB;
     while (curA != null) {
         lenA++;
         curA = curA.next;
     }
     while (curB != null) {
         lenB++;
         curB = curB.next;
     }
     curA = headA;
     curB = headB;
     if (lenA < lenB) {
         int temp = lenA;
         lenA = lenB;
         lenB = temp;
         ListNode curTemp = curA;
         curA = curB;
         curB = curTemp; 
     }
     int res = lenA - lenB;
     while(res-- > 0) {
         curA = curA.next;
     }
     while(curA != null) {
         if (curA == curB) {
             return curA;
         } else {
             curA = curA.next;
             curB  =curB.next;
         }
     }
     return null;
    }
}
```



### 5.8 环形链表Ⅱ

[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

思路：

俩个问题：①是否有环②环的入口

解决：①快慢指针，慢的走一步，快的每次走俩步，若有环，则一定会有俩个指针相等的时候

‘②初次相遇时，一个指针指向头，一个指针指向相遇的节点，每个指针同时一次走一步

相等时既是入口

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
      ListNode fast = head;
      ListNode slow = head;
      while(fast != null && fast.next != null) {
          slow = slow.next;
          fast = fast.next.next;
          if (fast == slow) {
              ListNode index1 = head;
              ListNode index2 = fast;
              while(index1 != index2) {
                  index1 = index1.next;
                  index2 = index2.next;
              }
              return index1;
          }
      }
      return null;
    }
}
```



### 5.9 三数之和

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

注意去重的思路吧，细节就是在去重上

不过要注意一点就是一定要**先将数组排好序**

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> record = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                return record;
            }
            if(i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] +nums[right];
                if (sum > 0) {
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    record.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    while(left < right && nums[right] == nums[right-1])right--;
                    while(left < right && nums[left] == nums[left+1])left++;
                    left++;
                    right--;
                }
            }
        }
        return record;
    }
}
```



### 5.10 四数之和

[18. 四数之和](https://leetcode-cn.com/problems/4sum/)

思路：

现在已经可以独立完整的写出三数之和，四数之和，但是也不知道是不是真的懂了

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> record = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i-1]) {
                continue;
            }
            for (int k = i + 1; k < nums.length; k++) {
                if (k > i + 1 && nums[k] == nums[k-1]) {
                    continue;
                }
                int left = k + 1;
                int right = nums.length - 1;
                while (left < right) {
                    if (nums[i] + nums[k] > target - nums[left] - nums[right]) {
                        right--;
                    } else if(nums[i] + nums[k] < target - nums[left] - nums[right]){
                        left++;
                    } else {
                        record.add(Arrays.asList(nums[i], nums[k], nums[left], nums[right]));
                        while(left < right && nums[right] == nums[right-1]) right--;
                        while(left < right && nums[left] == nums[left+1]) left++;
                        left++;
                        right--;
                    }
                }
            }
        }
        return record;
    }
}
```



## 6、栈和队列

### 6.1用栈实现队列

[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

思路：

用一个栈是无法模拟队列的，如果有俩个

则一个是输入栈，一个是输出栈，俩个结合使用即可

在这里要注意的就是什么时候使用输出栈，当队列需要取值，或者查看队头的时候，需要用到且输出栈为空的时候

则我们就应该将输入栈的内容全部输入到输出栈里，若不为空则不需要添加

```java
class MyQueue {
    Stack<Integer> stackIn; // 输出栈
    Stack<Integer> stackOut; // 输入栈
    public MyQueue() {
        stackIn = new Stack<>(); // 初始化
        stackOut = new Stack<>();
    }
    
    public void push(int x) {
        stackIn.push(x);
    }
    
    public int pop() {
        dumpStackIn();
        return stackOut.pop();
    }
    
    public int peek() {
        dumpStackIn();
        return stackOut.peek();
    }
    
    public boolean empty() {
        return stackIn.isEmpty() && stackOut.isEmpty();
    }

    public void dumpStackIn() { // 判断逻辑，核心在此只有当输出栈为空的时候才需要将输入栈所有的值移入
        if (!stackOut.isEmpty()) return;
        while(!stackIn.isEmpty()) {
            stackOut.push(stackIn.pop());
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```



### 6.2 用队列实现栈

[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

解法一：

上题用俩个栈实现了队列，故这题最先想到的也是能不能用俩个队列实现栈

可以是可以，但是俩个队列的用途和上题不一样了

这里第二个队列用作备份队列，也就是用来暂时存放数据的，

通过交换让第一个队列的数据顺序和栈保持一致

```java
class MyStack {
    Queue<Integer> queue1;
    Queue<Integer> queue2; //用于备份
    
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    public void push(int x) { // 这个方法调用后queue1的数据顺序和栈保持一致
        queue2.offer(x); //先将值放入备份队列中
        while(!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        } //queue2中存放的数据就是逆序的
        Queue<Integer> tempQueue = queue1; //每次queue1都为空 交换后queue1得到queue2的值
        queue1 = queue2;
        queue2 = tempQueue;
    }
    
    public int pop() {
       return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```

解法二：

通过一个队列其实也能实现栈的功能

若要pop的时候我们只需将队列中所有值（留最后一个值）都依次重新进入队列

那么之前的最后一个值不就变成此时的第一个值了吗

```java
class MyStack {
    Deque<Integer> queue;  
    
    public MyStack() {
        queue = new ArrayDeque<>();
    }
    
    public void push(int x) {
        queue.addLast(x); // == add
    }
    
    public int pop() {
       int size = queue.size();
       size--;
       while(size-- > 0) {
           queue.addLast(queue.peekFirst()); // == peek
           queue.pollFirst();  // == poll
       }
        int result = queue.pollFirst();
        return result;
    }
    
    public int top() {
        return queue.peekLast(); // 展示尾部
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}
```



### 6.3 有效的括号

[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

思路：

一般遇到匹配的问题，可以想到使用栈

这道题目出现括号不匹配的情况有三种

1. 左边的括号出现了多余
2. 括号没有多余，但是有括号不匹配的现象
3. 右边的括号出现了多余

针对第一、三种则是通过查看栈中是否有元素与之匹配来解决

第二种则是看字符串遍历完后栈内是否为空来解决

```java
class Solution {
       public boolean isValid(String s) {
           Stack<Character> stack = new Stack<>();
           for (int i = 0; i < s.length(); i++) {
               char element = s.charAt(i);
               if (element == '(') {
                   stack.push(')');
               } else if(element == '[') {
                   stack.push(']');
                } else if(element == '{') {
                   stack.push('}');
                } else if(stack.isEmpty() || stack.peek() != element) {//解决一三
                    return false;
                } else {
                    stack.pop();
                }
           }
           return stack.isEmpty();//解决二
    }
}
```



### 6.4 删除字符串中的所有相邻重复项

[1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

解法一：

这是一道字符匹配题，若相邻俩个相等，则都消去

可以用栈来解决，就是栈输出来的是逆序的，要注意字符串也要反转一下

```java
class Solution {
    public String removeDuplicates(String s) {
        ArrayDeque<Character> deque = new ArrayDeque<>();
        for (int i = 0; i < s.length(); i++) {
            char temp = s.charAt(i);
            if (deque.isEmpty() || deque.peek() != temp) {
                deque.push(temp);
            } else {
                deque.pop();
            }
        }
        String str = "";
        while(!deque.isEmpty()) {
            str = deque.pop() + str; //pop（）在str前面从而达到栈输出来的逆序得到反转
        }
        return str;
    }
}
```

解法二：

双指针，看到字符串问题，我的第一反应其实是双指针应该也能解决这个问题吧

用的就是双指针，涉及到具体的逻辑看代码去理解吧

多跟着模拟几遍

```java
class Solution {
    public String removeDuplicates(String s) {
        char[] ch = s.toCharArray();
        int slow = 0;
        int fast = 0;
        while(fast < s.length()) {
            ch[slow] = ch[fast];
            if (slow > 0 && ch[slow] == ch[slow - 1]) {
                slow--;
            } else {
                slow++;
            }
            fast++;
        }
        return new String(ch, 0, slow);
    }
}
```



### 6.5 逆波兰表达式求值

[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

逆波兰表达式也就是后缀表达式

当俩个操作数遇到符号了，就可以将俩个数执行操作符，然后就是消消乐的感觉了

利用栈的特点，非常适合来做匹配相消的问题

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < tokens.length; i++) { // 注意-和/的逻辑，因为栈是先进后出，所以这俩个操作符，要处理一下逻辑 
            if ("+".equals(tokens[i])) { // 常量放前面，用常量调用equals（）可以防止空指针的异常，如此处理更显健壮性
                stack.push(stack.pop() + stack.pop());
            } else if ("-".equals(tokens[i])) {
                stack.push(-stack.pop() + stack.pop());
            } else if ("*".equals(tokens[i])) {
                stack.push(stack.pop() * stack.pop());
            } else if ("/".equals(tokens[i])) {
                int temp1 = stack.pop();
                int temp2 = stack.pop();
                stack.push(temp2 / temp1);
            } else {
                stack.push(Integer.valueOf(tokens[i])); // 将字符串转化为整数
            }
        }
        return stack.pop();
    }
}
```



### 6.6 滑动窗口最大值



### 6.7 前K个高频元素



## 7、二叉树

### 7.1 二叉树理论基础

**二叉树**：每个根节点至多只能有左右俩个子节点

**满二叉树**：每个根节点都有俩个节点，分别是左右子节点

**二叉搜索树**：是一个有序树，特点如下

左边的子节点一定比根节点小，右边的子节点一定比根节点大（若左右不为空的情况下）

其左右子节点也可以作为搜索树

**平衡二叉搜索树**：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，

并且左右两个子树都是一棵平衡二叉树

**二叉树的存储形式**：可以通过链表，也可通过数组

**二叉树的遍历方式**：
深度优先遍历：前序遍历（中左右），中序遍历（左中右），后续遍历（左右中）

广度优先遍历：层序遍历

**二叉树的定义**：

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val) {
        this.val = val;
    }
    TreeNode(int val, TreeNode left, TreeNode right) {
        	this.val = val;
    		this.left = left;
    		this.right = right;
    }
}
```



### 7.2 二叉树的递归遍历

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

写递归遵循以下三点

①找到递归方法的参数有哪些，返回值类型是什么

②找到终止递归的条件

③写单层递归的逻辑

二叉树的递归遍历代码简单，但是是否理解递归的逻辑又是另一回事了

递归遍历：

二叉树的递归，每个节点其实会被访问三次

前序就是当第一次访问的时候打印或处理那个节点即可

中序就是第二次访问的时候打印或处理

后序就是第三次访问的时候打印或处理

```java
// 前序遍历
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        preOrder(root, result);
        return result;
    }
    public void preOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        result.add(root.val);
        preOrder(root.left, result);
        preOrder(root.right, result);
    }
}
// 中序遍历
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        inOrder(root, result);
        return result;
    }
    public void inOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        inOrder(root.left, result);
        result.add(root.val);
        inOrder(root.right, result);
    }
}
// 后序遍历
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postOrder(root, result);
        return result;
    }
    public void postOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return ;
        }
        postOrder(root.left, result);
        postOrder(root.right, result);
        result.add(root.val);
    }
}
```



### 7.3 二叉树的迭代遍历

如果不想用迭代来实现二叉树的遍历

还可以使用迭代遍历

因为栈本身就是一直递归的思路

前序遍历思路：

用栈来记录树的节点，入栈的顺序要注意下，因为是先进后出，所以若想实现中左右，则右节点需要比左节点先进去

进入循环后的步骤：

①先出栈

②打印或处理出栈的节点

③判断右节点是否为空，若有则入栈

④判断左节点是否为空，若有则入栈

中序遍历：

循环后的步骤：
①先将当前节点所有左节点入栈

②当左节点为空时，打印或处理节点

③再将所有右节点对应的所有左节点入栈

最后纵观一看其实是左中右（ 右里面的左中右）（ 右有里面的左中）

中在左的路上

最后打印出来的就是中序

后序遍历:
在前序遍历的基础上，遍历中改成中右左

最后统一反转，就变成了左右中，也就是所谓的后序遍历

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.right != null) {
                stack.push(node.right);
            } 
            if (node.left != null) {
                stack.push(node.left);
            }
        }
        return result;
    }
}

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
       List<Integer> result = new ArrayList<>();
       if (root == null) {
           return result;
       }
       Stack<TreeNode> stack = new Stack<>();
       TreeNode cur = root;
       while(cur != null || !stack.isEmpty()) {
           if (cur != null) {
               stack.push(cur);
               cur = cur.left;
           } else {
               cur = stack.pop();
               result.add(cur.val);
               cur = cur.right;
           }
       }
       return result;
    }
}

class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
       List<Integer> result = new ArrayList<>();
       if (root == null) {
           return result;
       }
       Stack<TreeNode> stack = new Stack<>();
       stack.push(root);
       while(!stack.isEmpty()) {
           TreeNode node = stack.pop();
           result.add(node.val);
           if (node.left != null) {
               stack.push(node.left);
           }
           if (node.right != null) {
               stack.push(node.right);
           }
       }
       Collections.reverse(result);
       return result;
    }
}
```



### 7.4 二叉树的层序遍历

#### 7.4.1 二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

二叉树的层序遍历又称为广度优先遍历

也就是一层层遍历

我们用队列来暂存每一层的节点

代码如下

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if (root == null) {
            return result;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        while(!deque.isEmpty()) {
            List<Integer> itemList = new ArrayList<>();
            int len = deque.size();
            while(len > 0) {
                TreeNode cur = deque.pop();
                itemList.add(cur.val);
                if (cur.left != null) deque.offer(cur.left);
                if (cur.right != null) deque.offer(cur.right);
                len--;
            }
            result.add(itemList);
        }
        return result;
    }
}
```



#### 7.4.2  二叉树的层序遍历Ⅱ

[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

思路就是先层序遍历，最后将得到的集合整体反转就行了

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if (root == null) {
            return result;
        }
        Deque<TreeNode> que = new LinkedList<>();
        que.offer(root);
        while(!que.isEmpty()) {
            int len = que.size();
            List<Integer> itemList = new ArrayList<>();
            while(len > 0) {
                TreeNode tempNode = que.pop();
                itemList.add(tempNode.val);
                if (tempNode.left != null) que.offer(tempNode.left);
                if (tempNode.right != null) que.offer(tempNode.right);
                len--;
            }
            result.add(itemList);
        }
        Collections.reverse(result);
        return result; 
    }
}
```



#### 7.4.3 二叉树的右视图

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

思路：层序遍历，最右边的节点一定是每一层的最后一个节点，故到了每层最后一个节点就加入到集合中

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
            TreeNode temp = queue.pollFirst();
            if (temp.left != null) queue.offer(temp.left);
            if (temp.right !=  null) queue.offer(temp.right);
            if (i == len - 1) result.add(temp.val);
        }            
       }
       return result;
    }
}
```



#### 7.4.4 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

思路：用层序遍历，记录每层的值之和，最后再计算每层的平均值放入集合即可

```java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int len = queue.size(); // 记录每层有多少元素
            Double leverSum = 0.0; // 记录每层元素的总值
           for (int i = 0 ; i < len; i++) {
                TreeNode temp = queue.pollFirst();
                leverSum += temp.val;
                if (temp.left != null) {
                    queue.addLast(temp.left);
                }
                if (temp.right != null) {
                    queue.addLast(temp.right);
                }

            }
            // 每遍历完一层就做一次求平均，且放入集合中
            res.add(leverSum / len);
        }
        return res;
    }
}
```



#### 7.4.5 N叉树的层序遍历

[429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

思路：还是层序遍历，模板不变，只是每层要多几个节点入队列罢了

注意下这个N叉树的定义就行了

所有孩子节点都存放在List<Node> 集合中

判断每一层的界限就是孩子节点后面是否为null，到了null就跳到下一层

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if (root == null) {
            return list;
        }
        Deque<Node> queue = new LinkedList<>();
        queue.offerLast(root);
        while (!queue.isEmpty()) {
            int len = queue.size();
            List<Integer> itemList = new ArrayList<>();
            for (int i = 0 ; i < len; i++) {
                Node cur = queue.pollFirst();
                itemList.add(cur.val);
                List<Node> children = cur.children;
                if (children == null || children.size() == 0) {
                    continue;
                }
                for (Node child : children) {
                    if (child != null) {
                       queue.offerLast(child);
                    }
                }
            }
            list.add(itemList);
        } 
        return list;
    }
}
```



#### 7.4.6 在每个树行中找最大值

[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

思路：

依旧是层序遍历，用一个变量max在遍历每一层中记录最大值即可，遍历的过程中就可以进行比较了

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offerLast(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            int max = Integer.MIN_VALUE;
            while(len > 0) {
                TreeNode cur = queue.pollFirst();
                max = Math.max(max, cur.val);
                if (cur.left != null) queue.offerLast(cur.left);
                if (cur.right != null) queue.offerLast(cur.right);
                len--;
            }
            result.add(max);
        }
        return result;
    }
}
```



#### 7.4.7 填充每个节点的下一个右侧节点指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

思路：

层序遍历，单层遍历的时候，记录头节点，然后将每个节点指向下一个节点，最后一个不指就行

```java
class Solution {
    public Node connect(Node root) {
        Deque<Node> queue = new LinkedList<>();
        if (root == null) {
             return root;
        }
        queue.addLast(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            Node cur = queue.pollFirst();
            if (cur.left != null) queue.addLast(cur.left);
            if (cur.right != null) queue.addLast(cur.right);
            for (int i = 1; i < len; i++) {
                Node next = queue.pollFirst();
                if (next.left != null) queue.addLast(next.left);
                if (next.right != null) queue.addLast(next.right);
                cur.next = next;
                cur = next;
            }
        }
        return root;
    }
}
```



#### 7.4.8 填充每个节点的下一个右侧节点指针Ⅱ

[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

一样的思路，一样的代码

```java
class Solution {
    public Node connect(Node root) {
        Deque<Node> queue = new LinkedList<>();
        if (root == null) {
             return root;
        }
        queue.addLast(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            Node cur = queue.pollFirst();
            if (cur.left != null) queue.addLast(cur.left);
            if (cur.right != null) queue.addLast(cur.right);
            for (int i = 1; i < len; i++) {
                Node next = queue.pollFirst();
                if (next.left != null) queue.addLast(next.left);
                if (next.right != null) queue.addLast(next.right);
                cur.next = next;
                cur = next;
            }
        }
        return root;
    }
}
```



#### 7.4.9 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

思路：

二叉树的层序遍历，遍历的层数，就是二叉树的最大深度，直接一个层序遍历搞定

```java
class Solution {
    public int maxDepth(TreeNode root) {
        Deque<TreeNode> queue = new LinkedList<>();
        if (root == null) {
            return 0;
        }
        queue.offerLast(root);
        int deepNumber = 0;
        while(!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                TreeNode temp = queue.pollFirst();
                if (temp.left != null) queue.offerLast(temp.left);
                if (temp.right != null) queue.offerLast(temp.right);
            }
            deepNumber++;
        }
        return deepNumber;
    }
}
```



#### 7.4.10 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

思路：

层序遍历不变

**叶子节点的特点就是左右节点都为空**

在单层遍历的时候加一个逻辑判断，当第一次出现叶子节点的时候，返回长度就是最小深度

```java
class Solution {
    public int minDepth(TreeNode root) {
        Deque<TreeNode> queue = new LinkedList<>();
        if (root == null) {
            return 0;
        }
        queue.offerLast(root);
        int deepNumber = 0;
        while(!queue.isEmpty()) {
            int len = queue.size();
            deepNumber++;
            for (int i = 0; i < len; i++) {
                TreeNode temp = queue.pollFirst();
                if (temp.left == null && temp.right == null) {return deepNumber;} // 第一次出现叶子节点会在这里
                if (temp.left != null) queue.offerLast(temp.left);
                if (temp.right != null) queue.offerLast(temp.right);
            }
            
        }
        return deepNumber;
    }
}
```



### 7.5 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

思路：

可以用深度优先遍历的前后遍历，也可以使用广度优先的层序遍历

核心就是在遍历的过程中，交换每个节点的左右孩子即可达到反转

```java
//DFS
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        swapChildren(root);
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
    public void swapChildren(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}

//BFS
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        Deque<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            while(len > 0) {
                TreeNode temp = queue.poll();
                swapChildren(temp);
                if (temp.left != null) queue.offer(temp.left);
                if (temp.right != null) queue.offer(temp.right);
                len--;
            }
        }
        return root;
    }
    public void swapChildren(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
```

### 7.6 对称二叉树

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

对称二叉树核心思想就是比较俩个子树的左右孩子是否对称

注意是，左子树的**左孩子**与右子树的**右孩子**的值是否相等且左子树的**右孩子**与右子树的**左孩子**是相等

若都相等则是对称的

方法一：递归法

递归三部曲：

①返回值类型是boolean型，递归函数的参数为左右俩个子树的根节点

②终止条件

1. 左节点空，右节点不空 --》false
2. 左节点非空，右节点空 --》false
3. 左节点空，右节点空 --》 true
4. 左右都不空，则比较左右的值，相等--》 true， 不相等 --》false

③单层逻辑

左子树的**左孩子**与右子树的**右孩子**的值是否相等 且 左子树的**右孩子**与右子树的**左孩子**是相等

有一个不相等都返回false

```java
class Solution {  
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return compare(root.left, root.right);
    }
    public boolean compare(TreeNode leftNode, TreeNode rightNode) {	// 确定返回值，及递归参数
        if (leftNode == null && rightNode != null) { // 确定终止条件
            return false;
        } else if (leftNode != null && rightNode == null) {
            return false;
        } else if (leftNode == null && rightNode == null) {
            return true;
        } else if (leftNode.val != rightNode.val) {
            return false;
        }
        boolean outside = compare(leftNode.left, rightNode.right); // 单层递归
        boolean inside = compare(leftNode.right, rightNode.left);
        boolean isSame = outside && inside;
        return isSame;
    }
}
```

方法二：迭代法

通过一个双端队列来判断根节点的左子树和右子树的内侧和外侧是否相等

```java
class Solution {  
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offerFirst(root.left);
        deque.offerLast(root.right);
        while(!deque.isEmpty()) {
            TreeNode leftNode = deque.pollFirst();
            TreeNode rightNode = deque.pollLast();
            if (leftNode == null && rightNode == null) {
                continue;
            }
            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
                return false;
            }
            deque.offerFirst(leftNode.left);
            deque.offerFirst(leftNode.right);
            deque.offerLast(rightNode.right);
            deque.offerLast(rightNode.left);
        }
        return true;
    }
}
```



#### 7.6.1 相同的树

[100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

和上题是一样的逻辑，只是在单层递归的时候改成左比左 右比右即可（因为题目是相同，而不是对称）

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        return compare(p, q);
    }

    public boolean compare(TreeNode leftNode, TreeNode rightNode) {
        if (leftNode == null && rightNode != null) { // 确定终止条件
            return false;
        } else if (leftNode != null && rightNode == null) {
            return false;
        } else if (leftNode == null && rightNode == null) {
            return true;
        } else if (leftNode.val != rightNode.val) {
            return false;
        }
        boolean outside = compare(leftNode.left, rightNode.left); // 单层递归
        boolean inside = compare(leftNode.right, rightNode.right);
        boolean isSame = outside && inside;
        return isSame;
    }
}
```



### 7.7 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

层序遍历的时候做过了，不再赘述

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        int max = 0;
        deque.offer(root);
        while(!deque.isEmpty()){
            int len = deque.size();
            max++;
            while(len > 0) {
                TreeNode temp = deque.pollFirst();
                if (temp.left != null) deque.offerLast(temp.left);
                if (temp.right != null) deque.offerLast(temp.right);
                len--;
            }
        }
        return max;
    }
}
```



### 7.8 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

层序遍历的时候做过了，不再赘述

```java
class Solution {
    public int minDepth(TreeNode root) {
         if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        int min = 0;
        deque.offer(root);
        while(!deque.isEmpty()){
            int len = deque.size();
            min++;
            while(len > 0) {
                TreeNode temp = deque.pollFirst();
                if (temp.left == null && temp.right == null) {
                    return min;
                }
                if (temp.left != null) deque.offerLast(temp.left);
                if (temp.right != null) deque.offerLast(temp.right);
                len--;
            }
        }
        return min;
    }
}
```





### 7.9 完全二叉树的节点个数

[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

前俩个方法就是普通二叉树遍历，每遍历一个加一即可

**方法三则是利用了完全二叉树的特性来解**

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满

满二叉树：节点个数为2^n - 1（n为树的层数）

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，

然后依然可以按照情况1来计算

方法一：后序遍历递归法

方法二：层序遍历迭代法

方法三：争对完全二叉树的解法

```java
// 递归法
class Solution {
    public int countNodes(TreeNode root) {
        return count(root);
    }
    public int count(TreeNode root) {
        if (root == null) return 0;
        int countLeft = count(root.left);
        int countRight = count(root.right);
        int countNode = countLeft + countRight + 1;
        return countNode;
    }
}

// 迭代法
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        int count = 0;
        deque.offer(root);
        while(!deque.isEmpty()){
            int len = deque.size();
            while(len > 0) {
                TreeNode temp = deque.pollFirst();
                count++;
                if (temp.left != null) deque.offerLast(temp.left);
                if (temp.right != null) deque.offerLast(temp.right);
                len--;
            }
        }
        return count;
    }
}

// 基于完全二叉树特性
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int leftDepth = getDepth(root.left);
        int rightDepth = getDepth(root.right);
        if (leftDepth == rightDepth) {// 左子树是满二叉树
            // 2^leftDepth其实是 （2^leftDepth - 1） + 1 ，左子树 + 根结点
            return (1 << leftDepth) + countNodes(root.right);
        } else {// 右子树是满二叉树
            return (1 << rightDepth) + countNodes(root.left);
        }
    }

    private int getDepth(TreeNode root) {
        int depth = 0;
        while (root != null) {
            root = root.left;
            depth++;
        }
        return depth;
    }  
}
```



### 7.10 平衡二叉树

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

求二叉树的高度，就得后序遍历，使用递归实现

三部曲

①返回类型int 递归参数当前节点

②终止条件 节点为空的时候

③单层逻辑

判断左右子树的高度差是否大于一，大就返回-1

最后在主方法里判断返回的值是否为-1，是就是false，反之true

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }
    public int getHeight(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int leftHeight = getHeight(node.left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(node.right);
        if (rightHeight == -1) {
            return -1;
        }
        if (Math.abs(leftHeight- rightHeight) > 1) {
            return -1;
        }
        return Math.max(leftHeight,rightHeight) + 1;
    }
}
```



### 7.11 二叉树的所有路径

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        List<Integer> paths = new ArrayList<>();
        traversal(root, paths, res);
        return res;
    }
    public void traversal(TreeNode root,List<Integer> paths, List<String> res) {
        paths.add(root.val);
        if (root.left == null && root.right == null) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < paths.size() - 1; i++) {
                sb.append(paths.get(i)).append("->");
            }
             sb.append(paths.get(paths.size() - 1));
            res.add(sb.toString());
            return;
        }
        if (root.left != null) {
            traversal(root.left, paths, res);
            paths.remove(paths.size() - 1);
        }
        if (root.right != null) {
            traversal(root.right, paths, res);
            paths.remove(paths.size() - 1);
        }
    }
}
```



### 7.12 左叶子之和

[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

思路：

左叶子之和的条件：左节点不为空，且左节点的左节点和右节点都要为空，才是左叶子

根据以上定义来实现递归求解

使用后序遍历

递归三部曲

①返回值类型int，递归参数root节点

②终止条件

root == null

③单层逻辑

当满足左叶子条件的时候，将左叶子的值加入到midSum变量中去

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftSum = sumOfLeftLeaves(root.left);
        int rightSum = sumOfLeftLeaves(root.right);

        int midSum = 0;
        if (root.left != null && root.left.left == null && root.left.right == null){
            midSum = root.left.val;
        } 
        int sum = midSum + leftSum + rightSum;
        return sum;
    }
}
```



### 7.13 找树左下角的值

[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

层序遍历迭代法

因为是求最后一层的最左节点

所以优先想到了层序遍历

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int lastLeft = 0;
        while(! queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                TreeNode temp = queue.pollFirst();
                if (i == 0) {
                    lastLeft = temp.val;   // 记录每层遍历的第一个值，到最后一层循环的时候第一个值就一定是最左节点的值
                }
                if (temp.left != null) queue.offerLast( temp.left);
                if (temp.right != null) queue.offerLast(temp.right);
                
            }
        }
        return lastLeft;
    }
}
```



### 7.14 路径总和

[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

思路：

判断递归函数是否有返回值

①遍历整个二叉树不用处理递归返回值，则不需要返回值

②遍历整个二叉树需要处理递归返回值，则需要返回值

③搜索一条路径时，则需要返回值来记录

本题使用深度遍历递归实现（前中后序遍历都可）

三部曲

①返回值boolean，递归参数根节点，计数器（用于记录与目标值的差）

②终止条件：若遍历到了叶子节点且计数器为0则返回true，若到了叶子节点计数器不为0返回false

③单层逻辑：看代码

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return traversal(root, targetSum - root.val);
    }
    public boolean traversal(TreeNode root, int count) {
        // 终止条件
        if (root.left == null && root.right == null && count == 0) return true;
        if (root.left == null && root.right == null) return false;

        // 单层逻辑
        if (root.left != null) {
            count -= root.left.val; // 递归，实施操作
            if (traversal(root.left, count)) return true;
            count += root.left.val; // 回溯，还原操作
        }
        if (root.right != null) {
            count -= root.right.val;
            if (traversal(root.right, count)) return true;
            count += root.right.val; 
        }
        return false;       
    }
}
```



#### 7.14.1 路径总和Ⅱ

[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

思路：

和上一题不一样的就是递归无返回值，因为要遍历整棵树

其余的思想大致都一样

```java
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
            List<List<Integer>> res = new ArrayList<>();
            if (root == null) return res;
            List<Integer> list = new LinkedList<>();
            traversal(root, targetSum, list, res);
            return res;
    }

    public void traversal(TreeNode root, int targetSum, List<Integer> path, List<List<Integer>> res) {
        path.add(root.val);
        if (root.left == null && root.right == null) {
            if (targetSum - root.val == 0) {
                res.add(new ArrayList<>(path));
            } 
            return ;
        }

        if (root.left != null) {
            traversal(root.left, targetSum - root.val, path, res);
            path.remove(path.size() - 1); // 回溯
        }
        if (root.right != null) {
            traversal(root.right, targetSum - root.val, path, res);
            path.remove(path.size() - 1);
        }

    }
}
```



### 7.15 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)



### 7.16 最大二叉树





## 8、回溯算法

### 8.1 组合

[77. 组合](https://leetcode-cn.com/problems/combinations/)

涉及到组合的问题就可以考虑使用回溯了

本题如果你使用暴力for循环，如果k为50，你就需要循环50次

故使用回溯算法来解决此类问题，通过每次递归加入一层for循环

回溯三部曲

①递归函数返回值与参数类型 ：void  int n， int k，int startIndex（用于记录每层for循环的起始位置）

②终止条件：当记录单个答案集合中元素的个数等于k时，终止本次递归并记录到最终集合中去

③单层逻辑：for循环，起始为startIndex，结束为n，里面是先处理节点，再递归，再回溯撤销处理

回溯法的搜索过程就是一个**树型结构的遍历过程**，for循环用来横向遍历，递归的过程是纵向遍历

```java
class Solution {
     List<List<Integer>> res = new ArrayList<>();
     LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        backtracking(n, k, 1);
        return res;
    }

    public void backtracking(int n, int k, int startIndex) { // 返回值与参数列表
        // 终止条件
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return ;
        }

        // 单层逻辑
        for (int i = startIndex; i <= n; i++) {
            path.add(i); // 处理节点
            backtracking(n, k, i + 1); // 递归
            path.removeLast();; // 回溯，撤销处理
        }
    }
}
```



### 8.2 组合Ⅲ

[216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

思路：

比组合那道题目要简单。搞懂了那道题目，这道题目就是微调就能ac了

回溯构成的树深度就是题目给的k，宽度为9

回溯三部曲

①递归函数的返回值及参数：返回值为void，参数为int k，int n，int sum，int startIndex

②终止条件为：它组合的个数为k，所以只要path集合元素中的个数为k的时候就终止

只不过里面要加个判断条件，当元素之和sum 等于 n 的时候，将path添加到res集合中

若没有则直接返回

③单层逻辑和组合一样，就是宽度遍历只到9，再多加一个统计path元素之和的操作即可

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>(); // 存放最终的结果集
    LinkedList<Integer> path = new LinkedList<>();// 存放单个结果
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(k, n, 0, 1);
        return res;
    }

    public void backtracking(int k, int n, int sum, int startIndex) { // 一部曲
        if (path.size() == k) { // 二部曲
            if (sum == n) {
                res.add(new ArrayList<>(path));
            }
            return;
        }

        for (int i = startIndex; i <= 9; i++) { // 三部曲
            sum += i; // 统计元素之和
            path.add(i);
            backtracking(k, n, sum, i + 1); // 递归 下一个起始为i+1
            sum -= i; // 回溯也别忘了撤销递归之前的所有操作，包括加和
            path.removeLast();
        }
    }
}
```



### 8.3 电话号码的字母组合

[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

思路：

考虑三个问题：

1. 如何处理电话号码和对应字母的转化（构建一个字符串数组形参，俩者之间的映射）
2. 处理非2-9数字的异常情况（多加几个判断条件）
3. 用多层循环可以解决这个题目吗（不能，如果是多个数字，循环就需要很多层，手写很麻烦）

综上所述：回溯算法三部曲

①递归函数的返回值与参数列表：返回值类型为void，参数为String digits，int index（用来记录digits到了哪个字符了），

再定义俩个全局变量分别用来存放结果集和单个结果

②终止条件：当index等于digits长度的时候终止

③单层逻辑：拿到digits中的每个字符转化为对应的数字，然后根据数字找到对应的字符集映射String[]  letterMapping

for循环里面的逻辑不变

```java
class Solution {
    List<String> result = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return list;
        }
        String[] letterMapping = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}; // 数字字符映射 （与电话保持一致）
        backtracking(digits, 0, letterMapping);
        return result;
    }

    public void backtracking(String digits, int index, String[] letterMapping) {
        if (index == digits.length()) {
            result.add(sb.toString());
            return;
        }
        int digit = digits.charAt(index) - '0'; // 将每个得到的字符转化为对应的数字
        String letters = letterMapping[digit]; // 将每个转化后的数字找到电话中对应的字符串
        for (int i = 0; i < letters.length(); i++) { // 遍历得到的字符串
            sb.append(letters.charAt(i)); 
            backtracking(digits, index + 1, letterMapping); // 递归记得是index + 1 ，遍历下一层
            sb.deleteCharAt(sb.length() - 1); // 回溯
        }
    }
}
```



### 8.4 组合求和

 [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

思路：

三部曲：

①递归函数参数及返回值：题目给的数组及目标值，记录单个结果的总和sum，记录遍历到哪个位置的startIndex，返回值为void

一个存放单个结果的集合path，最终结果的集合result

②终止条件：当sum + candidates[i] > target 的时候返回 相等记录结果

③单层逻辑和之前一样，就是startIndex每次传入都是i不需要加1，因为题目说了允许一个值多次被利用

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(candidates); // 提前排好序，这样后面递归的时候每次结果都可以少递归一次
        backtracking(candidates, target, result, new ArrayList<>(), 0, 0);
        return result;
    }

    public void backtracking(int[] candidates, int target, List<List<Integer>> result, List<Integer> path, int sum, int startIndex) {
        if (sum == target) { 
            result.add(new ArrayList<>(path));
            return;
        }

        for (int i = startIndex; i < candidates.length; i++) {
            if (sum + candidates[i] > target) break; // 排好序的作用在于此
            sum += candidates[i];
            path.add(candidates[i]);
            backtracking(candidates, target, result, path, sum, i); // 注意这不需要i+1，因为可重复利用
            sum -= candidates[i];
            path.remove(path.size() - 1);
        }
    }
}
```



### 8.5 组合求和Ⅱ

[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

总体大致上和上题没什么区别，就是**去重**这块要理解好来，就没问题了，而且数组一定要是有序的

```java
class Solution {
    List<List<Integer>> lists = new ArrayList<>();
    Deque<Integer> deque = new LinkedList<>();
    int sum = 0;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        //为了将重复的数字都放到一起，所以先进行排序
        Arrays.sort(candidates);
        //加标志数组，用来辅助判断同层节点是否已经遍历
        boolean[] flag = new boolean[candidates.length];
        backTracking(candidates, target, 0, flag);
        return lists;
    }

    public void backTracking(int[] arr, int target, int index, boolean[] flag) {
        if (sum == target) {
            lists.add(new ArrayList(deque));
            return;
        }
        for (int i = index; i < arr.length && arr[i] + sum <= target; i++) {
            //出现重复节点，同层的第一个节点已经被访问过，所以直接跳过
            if (i > 0 && arr[i] == arr[i - 1] && !flag[i - 1]) {
                continue;
            }
            flag[i] = true;
            sum += arr[i];
            deque.push(arr[i]);
            //每个节点仅能选择一次，所以从下一位开始
            backTracking(arr, target, i + 1, flag);
            int temp = deque.pop();
            flag[i] = false;
            sum -= temp;
        }
    }
}
```



### 8.6 分割回文串

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

```java
class Solution {
    List<List<String>> result = new ArrayList<>();
    Deque<String> path = new LinkedList<>(); 
    public List<List<String>> partition(String s) {
        backtracking(s, 0);
        return result;
    }

    public void backtracking(String s, int startIndex) {
        // 终止条件
        if (startIndex >= s.length()) {
            result.add(new ArrayList<>(path));
            return;
        }

        for (int i = startIndex; i < s.length(); i++) {
            if (isPalindrome(s, startIndex, i)) {
                // 左闭右开
                String str = s.substring(startIndex, i + 1);
                path.addLast(str);
            } else {
                continue;
            }
            backtracking(s, i + 1);
            path.removeLast();
        }
    }

    // 判断是否为回文串（双指针法）
    public boolean isPalindrome(String s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}
```



### 8.7 复原IP地址

[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

思路：

需要解决的问题有：

①每个有效ip地址有三个'.' 如何切割

②不能重复利用

③判断每个. 之间是否为有效数字

依旧使用回溯算法（回溯三部曲）

①递归函数返回值和形参列表 ：void， 列表（String s，int startIndex, int dotNum）

②终止条件：当出现了三个点的时候，就是终止的时候，只不过要加一层逻辑判断最后一个区间是否有效

③单层逻辑：看代码

```java
class Solution {
    List<String> result = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        if (s.length() > 12) return result;
        backtracking(s, 0, 0);
        return result;
    }

    // 用于递归
    public void backtracking(String s, int startIndex, int dotNum) { // dotNum用于记录点的个数
        // 终止条件
        if (dotNum == 3) {
            if (isValid(s, startIndex, s.length() - 1)) {
                result.add(s);
            }
            return ;
        }

        // 单层逻辑
         for (int i = startIndex; i < s.length(); i++) {
             if (isValid(s, startIndex, i)) {
                 s = s.substring(0, i + 1) + "." + s.substring(i + 1);// 加入 . 分割
                 dotNum++;
                 backtracking(s, i + 2, dotNum); // 注：因为加入了 .  所以需要一次加2（原本是一次加一因为不可重复索取）
                 dotNum--;
                 s = s.substring(0, i + 1) + s.substring(i + 2); //回溯的时候去掉 . 即可 
             } else {
                 break; // 无效直接跳过
             }
         }
    }

    // 用于判断字符串是否合法
    public boolean isValid(String s, int start, int end) {
        if (start > end) {
            return false;
        }
        if (s.charAt(start) == '0' && start != end) { // 去除开头为0的非法值
            return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s.charAt(i) > '9' || s.charAt(i) < '0') { // 遇到非法数字
                return false;
            }
            num = num * 10 + (s.charAt(i) - '0');
            if (num > 255) { // 大于255也是非法的
                return false;
            }
        }
        return true;
    }
}
```



### 8.8 子集

[78. 子集](https://leetcode-cn.com/problems/subsets/)

标准的回溯算法模板

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        if (nums.length == 0) {
            result.add(new ArrayList<>());
            return result;
        }
        backtracking(nums, 0);
        return result;
    }

    public void backtracking(int[] nums, int startIndex) {
        result.add(new ArrayList<>(path));
        if (startIndex >= nums.length) {
            return ;
        }

        for (int i = startIndex; i < nums.length; i++) {
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.removeLast();
        }
    }
}
```



### 8.9 子集Ⅱ

[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

思路：

就是组合+去重的问题，和上题不同的地方就在于去重，而去重之前有题目已经用过了

搬过来照用就行了

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        boolean[] use = new boolean[nums.length]; // 用于后面回溯
        backtracking(nums, 0, use);
        return result;
    }

    public void backtracking(int[] nums, int startIndex, boolean[] use) {
        result.add(new ArrayList<>(path));
        if (startIndex >= nums.length) {
            return;
        }

        for (int i = startIndex; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i - 1] && use[i - 1] == false) { // 去重的逻辑在此
                continue; 
            }
            use[i] = true;
            path.add(nums[i]);
            backtracking(nums, i + 1, use);
            use[i] = false;
            path.removeLast();
        }
    }
}
```



### 8.10 递增子序列

[491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

```java
class Solution {
    private List<Integer> path = new ArrayList<>();
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums,0);
        return res;
    }

    private void backtracking (int[] nums, int start) {
        if (path.size() > 1) {
            res.add(new ArrayList<>(path));
        }

        int[] used = new int[201];
        for (int i = start; i < nums.length; i++) {
            if (!path.isEmpty() && nums[i] < path.get(path.size() - 1) ||
                    (used[nums[i] + 100] == 1)) continue;
            used[nums[i] + 100] = 1;
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```



### 8.11 全排列

[46. 全排列](https://leetcode-cn.com/problems/permutations/)

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        boolean[] used = new boolean[nums.length];
        backtracking(nums, used);
        return result;
    }

    public void backtracking(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return ;
        }
        for (int i = 0; i < nums.length; i++) {
            if (used[i] == true) continue;
            used[i] = true;
            path.add(nums[i]);
            backtracking(nums, used);
            path.removeLast();
            used[i] = false;
        }
    }
}
```



### 8.12 全排列 Ⅱ

[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);
        backTrack(nums, used);
        return result;
    }

    private void backTrack(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过
            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过
            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if (used[i] == false) {
                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用
                path.add(nums[i]);
                backTrack(nums, used);
                path.removeLast();//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复
                used[i] = false;//回溯
            }
        }
    }
}
```



### 8.13 重新安排行程

[332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)



### 8.14 N皇后

[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)



### 8.15 解数独

[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)



## 9、贪心算法

### 9.1 分发饼干

[455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

先将俩个数组排好序，然后比较

尽可能多的去匹配，局部优解就是经可能的利用好每块饼干，大胃口吃大饼干，从而推导出整体最优解

并且无反例

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        if (s.length == 0) return 0;
        Arrays.sort(g);
        Arrays.sort(s);
        int num = 0;
        int gPoint = 0;
        int sPoint = 0;
        while(gPoint < g.length && sPoint < s.length) {
            if (s[sPoint] >= g[gPoint]) {
                num++;
                sPoint++;
                gPoint++;
            } else {
                sPoint++;
            }
        }
        return num;
    }
}
```



### 9.2 摆动序列

[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
       if (nums.length <= 1) {
           return nums.length;
       }
       int count = 1;
       int curDiff = 0; // 记录当前差值
       int preDiff = 0; // 记录上一个差值
       for (int i = 1; i < nums.length; i++) {
           curDiff = nums[i] - nums[i-1];
           if ((curDiff > 0 && preDiff <= 0) ||(curDiff < 0 && preDiff >= 0)) {
               count++;
               preDiff = curDiff;
           }
       }
       return count;
    }
}
```



### 9.3 最大子数组和

[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        int sum = Integer.MIN_VALUE;
        int count = 0;
        for (int i = 0; i < nums.length;i++) {
            count += nums[i];
            sum = Math.max(sum,count);
            if (count <= 0) {
                count = 0;
            }
        }
        return sum;
    }
}
```



### 9.4 买卖股票的最佳时期 Ⅱ

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

思路：

计算每天的利润，只收集正利润，最后得到就是最大利润

局部最优是收取所有的正利润，最后得出整体最优

```java
class Solution {
    public int maxProfit(int[] prices) {
       int result = 0;
       for (int i = 1; i < prices.length; i++) {
           result += Math.max((prices[i] - prices[i - 1]), 0);
       }
       return result;
    }
}
```



### 9.5 跳跃游戏

[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

思路：

**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

```java
class Solution {
    public boolean canJump(int[] nums) {
       if (nums.length == 1) return true;
       int cover = 0;
       for (int i = 0; i <= cover; i++) {
           cover = Math.max(i + nums[i], cover);
           if (cover >= nums.length - 1) {
               return true;
           }
       }
       return false;
    }
}
```



### 9.6 跳跃游戏 Ⅱ

[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

```java
class Solution {
    public int jump(int[] nums) {
        if (nums.length == 1) return 0;
        int curDiscount = 0; // 记录当前的覆盖范围
        int ans = 0; // 用于记录步长
        int nextDiscount = 0; // 记录下一个覆盖范围
        for (int i = 0; i < nums.length; i++) {
            nextDiscount = Math.max(i + nums[i], nextDiscount);
            if (i == curDiscount) {
                if (curDiscount != nums.length - 1) {
                    ans++;
                    curDiscount = nextDiscount;
                    if (nextDiscount >= nums.length - 1) break;
                } else {
                    break;
                }
            }
        }
        return ans;
    }
}
```



### 9.7 K 次取反后最大化的数组和

[1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

局部最优是将所有的负数都去取反为正数（若k>0）从而达到整体最优

若k还大于0，那局部最优只需要取反最小的正数（因为没有负数了），达到整体最优

ps:通过自定义排序实现数组的从大到小排序，我觉得这里还有可以优化的空间，我这样写花的时间好多

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
            sortByABS(nums); // 按数组元素的绝对值从大到小排序
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] < 0 && k >0) { // 将所有负数取反
                    nums[i] *= -1;
                    k--;
                }
            }
            if (k % 2 == 1) nums[nums.length - 1] *= -1; // 若k>0,看k是奇数还是偶数，奇数就反转一次最小正数即可，偶数不用反转，就是它本身
            int result = 0;
            for (int item : nums) result += item;
            return result;
    }

    public void sortByABS(int[] array) { 
        for (int i = 0; i < array.length; i++) { // 要排序的趟数
            for (int j = 0;j < array.length - i - 1; j++) { // 要比较的次数
                if(Math.abs(array[j]) < Math.abs(array[j+1])) {
                    int temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
        }
    }
}
```



### 9.8 加油站

[134. 加油站](https://leetcode-cn.com/problems/gas-station/)

方法一：

- 情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的
- 情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。
- 情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点。

方法二：

首先用个变量记录跑完一圈的总油量若小于0，则不能环绕一圈，start记录可能成为出发点的变量

然后再拿个变量记录当前剩余油量，若小于0，则必不是起始地点，可以将start+1，curSum清0（局部最优）

```java
// 方法一
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int curSum = 0;
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < gas.length; i++) {
            int rest = gas[i] - cost[i];
            curSum += rest;
            if(curSum < min) {
                min = curSum;
            }
        }
        if (curSum < 0) return -1; // 情况1
        if (min >= 0) return 0; // 情况2
        for (int i = gas.length - 1; i >= 0; i--) { // 情况3
            int rest = gas[i] -cost[i];
            min += rest;
            if (min >= 0) return i;
        }
        return -1;
    }
}

// 方法二
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
      int curSum = 0;
      int totalSum = 0;
      int start = 0;
      for (int i = 0; i < gas.length; i++) {
          curSum += gas[i] - cost[i];
          totalSum += gas[i] - cost[i];
          if (curSum < 0) {
              start = i + 1;
              curSum = 0;
          }
      }
      if (totalSum < 0) return -1;
      return start;
    }
}
```



### 9.9 分发糖果

[135. 分发糖果](https://leetcode-cn.com/problems/candy/)

```java
class Solution {
    public int candy(int[] ratings) {
        int[] candyVec = new int[ratings.length];
        candyVec[0] = 1;
        // 从前向后，比较右边的孩子是否比我分高
        for (int i = 1; i < ratings.length; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candyVec[i] = candyVec[i - 1] + 1;
            } else {
                candyVec[i] = 1;
            }
        }
		
        // 从后往前，比较左边的孩子是否比我分高
        for (int i = ratings.length - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                candyVec[i] = Math.max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        int res = 0;
        for (int item : candyVec) {
            res += item;
        }
        return res;
    }
}
```



### 9.10 柠檬水找零

[860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

思路：

题目给的条件是固定的

三种情况：

1. 付5美金，不用找零
2. 付10美金，找5美金
3. 付20美金，付15美金（可以有俩种方案，一个10+5，一个三个5）

局部最优就是当付款为20美金的时候，我们优先使用10+5 的方式，因为10美金只能用来找20的零钱

优先使用掉，进而推到全局最优

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0;
        int ten = 0;
        for (int i = 0; i < bills.length; i++) {
            // 情况一
            if (bills[i] == 5) {
                five++;
            }
            // 情况二
            if (bills[i] == 10) {
                if (five <= 0) {
                    return false;
                }
                five--;
                ten++;
            }
            // 情况三，由于此题20美金无法用来找零所以不用创建变量来记录20美金的个数
            if (bills[i] == 20) {
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                } else if (five >= 3) {
                    five -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    }
}
```



### 9.11 根据身高重建队列

[406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 身高从大到小排（身高相同k小的站前面）
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];
            return b[0] - a[0];
        });

        LinkedList<int[]> que = new LinkedList<>();

        for (int[] p : people) {
            que.add(p[1],p);
        }

        return que.toArray(new int[people.length][]);
    }
}
```



### 9.12 用最少数量的剪引爆气球

[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if (points.length == 0) return 0;
        Arrays.sort(points,(o1, o2) -> Integer.compare(o1[0], o2[0])); // 按左边界排序
        int count = 1;
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > points[i - 1][1]) { // 比较当前的最左和上一个的最右，
                count++;
            } else {
                points[i][1] = Math.min(points[i][1], points[i - 1][1]); // 把最小的有边界赋给当前，因为要确保一个箭可以射到在这个范围内的所有气球
            }
        }
        return count;
    }
}
```



### 9.13 无重叠区间

[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> {
            if (a[0] == a[0]) return a[1] - b[1];
            return a[0] - b[0];
        });
        int count = 0;
        int edge = Integer.MIN_VALUE;
        for (int i = 0; i < intervals.length; i++) {
            if (edge <= intervals[i][0]) {
                edge = intervals[i][1];
            } else {
                count++;
            }
        }
        return count;
    }
}
```



### 9.14 划分字母区间

[763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> list = new LinkedList<>();
        int[] hash = new int[26];
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            hash[chars[i] - 'a'] = i;  // 统计每个字母的最右边界
        }
        int left = 0;
        int right = 0;
        for (int i = 0; i < chars.length; i++) {
            right = Math.max(right, hash[chars[i] - 'a']); // 不断更新最右边界
            if (i == right) {
                list.add(right - left + 1);
                left = i + 1;
            }
        }
        return list;
    }
}
```



### 9.15 合并区间

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> res = new LinkedList<>();
        Arrays.sort(intervals, (o1, o2) -> Integer.compare(o1[0], o2[0])); // 按左边界从小到大排序
        int start = intervals[0][0];
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] > intervals[i - 1][1]) { // 未重合加入
                res.add(new int[] {start, intervals[i - 1][1]});
                start = intervals[i][0];
            } else {
                intervals[i][1] = Math.max(intervals[i][1], intervals[i - 1][1]); // 重合就合并
            }
        }
        res.add(new int[]{start, intervals[intervals.length - 1][1]});
        return res.toArray(new int[res.size()][]);
    }
}
```



### 9.16 单调递增的数字

[738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        if (n==0)return 0;
        char[] chars= Integer.toString(n).toCharArray();
        int start=Integer.MAX_VALUE;//start初始值设为最大值，这是为了防止当数字本身是单调递增时，没有一位数字需要改成9的情况
        for (int i=chars.length-1;i>0;i--){
            if (chars[i]<chars[i-1]){
                chars[i-1]--;
                start=i;
            }
        }
        StringBuilder res=new StringBuilder();
        for (int i=0;i<chars.length;i++){
            if (chars[i]=='0'&&i==0)continue;//防止出现09这样的情况
            if (i>=start){
                res.append('9');
            }else res.append(chars[i]);
        }
        return Integer.parseInt(res.toString());
    }
}
```



### 9.17 买卖股票的最佳时机含手续费

[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
         int result = 0;
        int minPrice = prices[0]; // 记录最低价格
        for (int i = 1; i < prices.length; i++) {
            // 情况二：相当于买入
            if (prices[i] < minPrice) minPrice = prices[i];

            // 情况三：保持原有状态（因为此时买则不便宜，卖则亏本）
            if (prices[i] >= minPrice && prices[i] <= minPrice + fee) {
                continue;
            }

            // 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出
            if (prices[i] > minPrice + fee) {
                result += prices[i] - minPrice - fee;
                minPrice = prices[i] - fee; // 情况一，这一步很关键
            }
        }
        return result;
    }
}
```



### 9.18 监控二叉树

[968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/)

```java
class Solution {
    private int count = 0;
    public int minCameraCover(TreeNode root) {
        if (trval(root) == 0) count++;
        return count;
    }

    private int trval(TreeNode root) {
        if (root == null) return -1;

        int left = trval(root.left);
        int right = trval(root.right);

        if (left == 0 || right == 0) {
            count++;
            return 2;
        }

        if (left == 2 || right == 2) {
            return 1;
        }

        return 0;
    }
}
```



## 10、动态规划

### 10.1 斐波那契数

[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)
 动规五部曲：
 ①确定dp数组以及下标的含义
 dp[i]的定义为：第i个斐波那契数的值为dp[i]
 ②确定递推公式
 dp[i] = dp[i-1] + dp[i-2]
 ③dp数组如何初始化
 dp[0] = 0
 dp[1] = 1
 ④确定遍历顺序
 我们想要得到第i个数就要依赖前俩个数的值，故从前往后遍历
 ⑤举例推导dp数组
 例如dp[10]：
 0，1，1，2，3，5，8，13，21，34，55

```java
// 时间复杂度O(n),空间复杂度o(n)
class Solution {
    public int fib(int n) {
        if (n <= 1) return n;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}

// 时间复杂度O(n),空间复杂度o(1)
class Solution {
    public int fib(int n) {
        if (n <= 1) return n;
        int dp0 = 0;
        int dp1 = 1;
        int sum = 0; // 用于后续给n - 1赋值
        for (int i = 2; i <= n; i++) {
            sum = dp0 + dp1;
            dp0 = dp1; // n - 2
            dp1 = sum; // n - 1
        }
        return dp1;
    }
}
```



### 10.2 爬楼梯

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

动规五部曲：

①确定dp数组以及下标的含义

dp[i]：爬到i层楼梯，可以有dp[i]种方法

②确定递推公式

想要到第i层有俩种情况，到了第i-1层再走一步

或者到了第i-2层走俩步，所以想要到i层，俩者的情况要想加

dp[i] = dp[i-1] + dp[i-2]

③dp数组的初始化

dp[1] = 1

dp[2] = 2

④遍历顺序

从前往后（从递推公式可以看出）

⑤举个例子

dp[4] = 5

1,2,3,5

```java
// 和上题的斐波那契数一样的有俩种方法，过程几乎一样，但是思路还是有不同的
class Solution {
    public int climbStairs(int n) {
        if (n <= 1) return n;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}

class Solution {
    public int climbStairs(int n) {
        if (n <= 1) return n;
        int dp1 = 1;
        int dp2 = 2;
        int sum = 0;
        for (int i = 3; i <= n; i++) {
            sum = dp1 + dp2;
            dp1 = dp2;
            dp2 = sum;
        }
        return dp2;
    }
}
```



### 10.3 使用最小花费爬楼梯

[746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

能否做出来题除了自己的理解能力外，题目是否描述的有歧义或清晰也是有很大的关系的

这道题描述的真绝，题目的意思是**cost是到达本层所需要支付的费用**，更便于理解

还有就是**顶楼的费用不在cost里面**，这个要说清楚，也就是说顶楼不需要付费

cost只有除了顶楼以外所有楼层需要支付的费用，搞懂了这个，题目就算理解了

动规五部曲

①确定dp数组及下标的含义

dp[i]: 表示的是到达i层所需要的最少费用为dp[i]

②确定递推公式

dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i] (因为cost是到了本层就得支付，所以是cost[i]，而不是cost[i-1]或cost[i-2])

③dp数组的初始化

dp[0] = cost[0]

dp[1] = cost[1]

④遍历顺序

从前往后

⑤举例推导dp数组

![](D:\Typoramd\java学习笔记\photo\屏幕截图 2022-03-17 092236.png)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length];
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < cost.length; i++) {
            dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        return Math.min(dp[dp.length - 1], dp[dp.length - 2]);
    }
}

// 精简版
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int dp0 = cost[0];
        int dp1 = cost[1];
        int sum = 0;
        for (int i = 2; i < cost.length; i++) {
            sum = Math.min(dp0, dp1) + cost[i];
            dp0 = dp1;
            dp1 = sum;
        }
        return Math.min(dp0, dp1);
    }
}
```



### 10.4 不同路径

[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

动规五部曲：

①确定dp数组以及下标的含义

dp[i] [j]:表示的是到达（i，j）这个位置有dp[i] [j]条路线

②递推公式

dp[i] [j] = dp[i - 1] [j] + dp[i] [j-1] (因为只能向下或向右，所以俩种情况都要加进去)

③dp数组初始化

dp[i] [0] = 1; dp[0] [j] = 1;（将第一行所有赋值为1，和第一列所有赋值为1）

④遍历顺序

从左到右层层遍历

⑤举例推导dp

![](D:\Typoramd\java学习笔记\photo\屏幕截图 2022-03-17 095220.png)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) { // 将第一列初始化为1
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) { // 将第一行初始化为1
            dp[0][i] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```



### 10.5 不同路径Ⅱ

[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

和上题思路差不多，主要就是在dp初始化，和递推公式分别加上判断为障碍物的条件即可

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length; // 确定列
        int n = obstacleGrid[0].length; // 确定行
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) { 
            if (obstacleGrid[i][0] == 1) break; // 若遇到障碍物下面就走不了直接跳出
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            if (obstacleGrid[0][i] == 1) break; // 若遇到障碍物后面就走不了直接跳出
            dp[0][i] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue; // 遇到障碍物跳出此次遍历
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```



### 10.6 整数拆分

[343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

动规五部曲

①确定dp数组已经下标的含义

dp[i]: 拆分整数i最大的乘积结果为dp[i]

②递推公式

dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))

③dp数组的初始化

dp[2] = 1

④确定遍历顺序

从前往后

⑤举个例子推到dp数组

![](D:\Typoramd\java学习笔记\photo\屏幕截图 2022-03-17 102921.png)

```java
class Solution {
    public int integerBreak(int n) {
        //dp[i] 为正整数 i 拆分后的结果的最大乘积
        int[]dp=new int[n+1];
        dp[2]=1;
        for(int i=3;i<=n;i++){
            for(int j=1;j<=i-j;j++){
                // 这里的 j 其实最大值为 i-j,再大只不过是重复而已，
                //并且，在本题中，我们分析 dp[0], dp[1]都是无意义的，
                //j 最大到 i-j,就不会用到 dp[0]与dp[1]
                dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
                // j * (i - j) 是单纯的把整数 i 拆分为两个数 也就是 i,i-j ，再相乘
                //而j * dp[i - j]是将 i 拆分成两个以及两个以上的个数,再相乘。
            }
        }
        return dp[n];
    }
}
```



### 10.7 不同的二叉搜索树

[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

首先要知道二叉搜索树的概念

当左树不为空的时候，左树所有节点的值都小于其根节点

当右树不为空的时候，右树所有节点的值都大于其根节点

动规五部曲

①确定dp数组及下标的含义

dp[i] :表示到i节点有多少种不同的二叉搜索树

②确定递推公式

dp[i]  += dp[j - 1] * dp[i - j]

上述公式是通过找规律得出的

![](D:\Typoramd\java学习笔记\photo\屏幕截图 2022-03-18 083830.png)

依次从小到大选取j作为头节点，j - 1为左节点的个数，i - j 则表示右节点的个数（以j为头节点来看的）

③dp数组初始化

dp[0] = 1（如果设为0 的话，有乘法的结果变为0）

④遍历顺序

从前往后，因为后面的节点依赖前面节点的dp值

⑤举个例子推导dp

i：	0	1	2	3	4	5

dp：1	1	2	5 	14	42

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
// 代码极其简单，但是关键就是五部曲你是否能想到
```



### 10.8 分割等和子集

[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums == null || nums.length == 0) return false;
        int n = nums.length;
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        //总和为奇数，不能平分
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < n; i++){
            for(int j = target; j >= nums[i]; j--){
                //物品 i 的重量是 nums[i]，其价值也是 nums[i]
                dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
```



### 10.9 最后一块石头的重量 Ⅱ

[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int i : stones) {
            sum += i;
        }
        int target = sum >> 1;
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}
```



### 10.10 目标和

[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        /**
         *将数组分为俩个部分，大于0的right，小于0的left
         *由题可知left+right == sum，且left - right == target时才算一个方案
         *由上推到 left = （sum + target）/ 2 由于target和sum都是确定的，所以left也一定可以确定
         *即背包的容量就是left
         */
        int sum = 0;
        for (int i : nums) { // 计算总和
            sum += i;
        }
        if ((target + sum) % 2 == 1) return 0; // 若所得为奇数，则得到的值有小数，对于整数来说，肯定没有方案
        if (Math.abs(target) > sum) return 0; // 若目标数都大于总和了，也肯定没有方案
        int bagTarget = (target + sum) / 2; // 得到left
        int[] dp = new int[bagTarget + 1];
        dp[0] = 1; // 初始化
        for (int i = 0; i < nums.length; i++) {
            for (int j = bagTarget; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]]; // 递推公式
            }
        }
        return dp[bagTarget];
    }
}
```



### 10.11 一和零

[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        int zeroNumber = 0;
        int oneNumber = 0;
        for (String str : strs) {
            zeroNumber = 0;
            oneNumber = 0;
            for (char item : str.toCharArray()) {
                if (item == '0') {
                    zeroNumber++;
                } else {
                    oneNumber++;
                }
            }
            for (int i = m; i >= zeroNumber; i--) {
                for (int j = n; j >= oneNumber; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNumber][j - oneNumber] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```



### 10.12 零钱兑换 Ⅱ

[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
```



### 10.13 组合总和Ⅳ

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        // 组合先遍历物品再背包，排列先遍历背包再遍历物品
        for (int i = 0; i <= target; i++) { // 遍历背包
            for (int j = 0; j < nums.length; j++) {  // 遍历物品
                if (i >= nums[j]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
}
```



### 10.14 爬楼梯

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        int[] res = {1, 2};
        dp[0] = 1;
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < res.length; j++) {
                if (i >= res[j]) {
                    dp[i] += dp[i - res[j]];
                }
            }
        }
        return dp[n];
    }
}
```



### 10.15 零钱兑换

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[amount + 1];
        for (int i = 0; i < dp.length; i++) {
            dp[i] = max;
        }
        dp[0] = 0;
        for (int i = 0; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (i >= coins[j] && dp[i - coins[j]] != max) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        if (dp[amount] == max) return -1;
        return dp[amount];
    }
}
```



### 10.16 完全平方数

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

```java
class Solution {
    public int numSquares(int n) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[n + 1];
        for (int i = 0; i < dp.length; i++) {
            dp[i] = max;
        }
        dp[0] = 0;
        for (int i =  1; i <= n; i++) {
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
}
```



### 10.17 单词拆分

[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] valid = new boolean[s.length() + 1];
        valid[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (wordDict.contains(s.substring(j,i)) && valid[j]) {
                    valid[i] = true;
                }
            }
        }
        return valid[s.length()] ;
    }
}
```



### 10.18 打家劫舍

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```java
class Solution {
    public int rob(int[] nums) {
      if (nums.length == 1) return nums[0];
      int[] dp = new int[nums.length];
      // dp初始化
      dp[0] = nums[0];
      dp[1] = Math.max(dp[0], nums[1]);
      for (int i = 2; i < nums.length; i++) {
          // 递推公式
          dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
      }
      return dp[nums.length - 1];
    }
}
```



###  10.19 打家劫舍 Ⅱ

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int result1 = robRange(nums, 0, nums.length - 2);
        int result2 = robRange(nums, 1, nums.length - 1);
        return Math.max(result1, result2);
    }

    public int robRange(int[] nums, int start, int end) {
        if (end == start) return nums[start];
        int[] dp = new int[nums.length];
        dp[start] = nums[start];
        dp[start + 1] = Math.max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
}
```



### 10.20 打家劫舍 Ⅲ

[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int rob(TreeNode root) {
        int[] res = robAction1(root);
        return Math.max(res[0], res[1]);
    }
    public int[] robAction1(TreeNode root) {
        int res[] = new int[2];
        if (root == null)
            return res;

        int[] left = robAction1(root.left);
        int[] right = robAction1(root.right);

        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        res[1] = root.val + left[0] + right[0];
        return res;
    }
}
```



### 10.21 买卖股票的最佳时机

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```java
// 股票只能进行一次买卖
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int[][] dp = new int[prices.length][2]; // 0表示持有 1表示不持有
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0],  -prices[i]); // 当天持有
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); // 当天不持有
        }
        return dp[prices.length - 1][1];
    }
}
```



### 10.22 买卖股票的最佳时机 Ⅱ

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```java
// 股票可以进行多次交易
class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null || prices.length == 0) {
            return 0;
        }
        int[][] dp = new int[prices.length][2];
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 不一样的地方在这
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.length - 1][1];
    }
}
```



### 10.23 买卖股票的最佳时机 Ⅲ

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

```java
// 股票只能进行俩次买卖
class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null || prices.length == 0) {
            return 0;
        }
        int[][] dp = new int[prices.length][5];
        dp[0][0] = 0; // 不操作
        dp[0][1] -= prices[0]; // 第一次买入
        dp[0][2] = 0; // 第一次卖出 
        dp[0][3] -= prices[0]; // 第二次买入
        dp[0][4] = 0; // 第二次卖出
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.length - 1][4];
    }
}
```



### 10.24 买卖股票的最佳时机 Ⅳ

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

```java
// 可以将股票进行k次交易
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length == 0) {
            return 0;
        }
        int[][] dp = new int[prices.length][2 * k + 1];
        for (int i = 1; i < 2 * k; i += 2) {  // dp初始化
            dp[0][i] = -prices[0];
        }
        for (int i = 1; i < prices.length; i++) {
            for (int j = 0; j < 2 * k ; j += 2) {
                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]); // 奇数就买入
                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]); // 偶数就卖出
            }
        }
        return dp[prices.length - 1][2 * k];
    }
}
```



### 10.25 最佳买卖股票时机含冷冻期

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        int[][] dp = new int[prices.length][2];

        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]);
        dp[1][1] = Math.max(dp[0][1], -prices[1]);

        for (int i = 2; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
        }

        return dp[prices.length - 1][0];
    }
}
```



### 10.26 买卖股票的最佳时机含手续费

[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int[][] dp = new int[prices.length][2];
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee); // 相比于卖股票Ⅱ就是这里不一样
        }
        return dp[prices.length - 1][1];
    }
}
```



### 10.27 最长递增子序列

[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 1) {
            return 1;
        }

        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1); // dp初始化
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if(nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        int result = 1;
        for (int i : dp) {
            result = result > i ? result : i;
        }
        return result;
    }
}
```



### 10.28 最长连续递增序列

[674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if (nums.length == 1) return 1;
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1); // 初始化
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i + 1] > nums[i]) {
                dp[i + 1] = dp[i] + 1;
            }
        }
        int result = 1;
        for (int i : dp) {
            result = result > i ? result : i;
        }
        return result;
    }
}
```



### 10.29  最长重复子数组

[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        int result = 0;
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) {
                    result = dp[i][j];
                }
            }
        }
        return result;
    }
}
```



### 10.30 最长公共子序列

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.length()][text2.length()];
    }
}
```



### 10.31 不相交的线

[1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[nums1.length][nums2.length];
    }
}
```



### 10.32最大子数组和

[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        int[] dp = new int[nums.length];
        dp[0] = nums[0]; // 初始化
        int result = dp[0]; // 用于记录最大值
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
            if (dp[i] > result) {
                result = dp[i];
            }
        }
        return result;
    }
}
```



### 10.33 判断子序列

[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

```java
// 双指针
class Solution {
    public boolean isSubsequence(String s, String t) {
        int p1 = 0; // s的指针
        int p2 = 0; // t的指针
        int result = 0; // 记录相等的长度
        while(p1 < s.length() && p2 < t.length()) {
            if (s.charAt(p1) == t.charAt(p2)) {
                p1++;
                result++;
            }
            p2++;
        }
        return result == s.length();
    }
}

// dp
class Solution {
    public boolean isSubsequence(String s, String t) {
        int length1 = s.length();
        int length2 = t.length();
        int[][] dp = new int[length1 + 1][length2 + 1];
        for (int i = 1; i <= length1; i++) {
            for (int j = 1; j <= length2; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }
        if (dp[length1][length2] == length1) {
            return true;
        }
        return false;
    }
}
```



### 10.34 不同的子序列

[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

```java
class Solution {
    public int numDistinct(String s, String t) {
        int[][] dp = new int[s.length() + 1][t.length() + 1];
        for (int i = 0; i < s.length() + 1; i++) { // dp初始化
            dp[i][0] = 1;
        }
        
        for (int i = 1; i < s.length() + 1; i++) {
            for (int j = 1; j < t.length() + 1; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                }else{
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        
        return dp[s.length()][t.length()];
    }
}
```



### 10.35  两个字符串的删除操作

[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int length1 = word1.length();
        int length2 = word2.length();
        int[][] dp = new int[length1 + 1][length2 + 1];
        for (int i = 0; i <= length1; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= length2; j++) {
            dp[0][j] = j;
        }
        for (int i = 1; i <= length1; i++) {
            for (int j = 1; j <= length2; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    int temp = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); // 删除左边字符，删除右边字符
                    dp[i][j] = Math.min(temp, dp[i - 1][j - 1] + 2); // 俩边字符都删除
                }
            }
        }
        return dp[length1][length2];
    }
}
```



### 10.36 编辑距离

[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int length1 = word1.length();
        int length2 = word2.length();
        int[][] dp = new int[length1 + 1][length2 + 1];
        for (int i = 0; i <= length1; i++) { // 初始化
            dp[i][0] = i;
        }
        for (int j = 0; j <= length2; j++) { // 初始化
            dp[0][j] = j;
        }
        for (int i = 1; i <= length1; i++) {
            for (int j = 1; j <= length2; j++) {
                if(word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];  // 不做变化
                } else {
                    int temp = Math.min(dp[i - 1][j], dp[i][j - 1]); // 对元素的删除和插入都是这俩种状态
                    dp[i][j] = Math.min(temp, dp[i - 1][j - 1]) + 1; // 对元素的修改
                }
            }
        }
        return dp[length1][length2];
    }
}
```



### 10.37 回文子串

[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

```java
class Solution {
    public int countSubstrings(String s) {
        if (s.length() == 1) {
            return 1;
        }
        boolean[][] dp = new boolean[s.length()][s.length()];
        int result = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            for (int j = i; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i <= 1) {
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) {
                        result++;
                        dp[i][j] = true;
                    }
                } else {
                    dp[i][j] = false;
                }
            }
        }
        return result;
    }
}
```



### 10.38 最长回文子序列

[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

```java
public class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] dp = new int[len + 1][len + 1];
        for (int i = len - 1; i >= 0; i--) { // 从后往前遍历 保证情况不漏
            dp[i][i] = 1; // 初始化
            for (int j = i + 1; j < len; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1]));
                }
            }
        }
        return dp[0][len - 1];
    }
}
```



## 11、单调栈

### 11.1 每日温度

[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] answer = new int[temperatures.length];
        if (temperatures.length <= 1) {
            return answer;
        }
        int fast = 1;
        int slow = 0;
        while (slow < temperatures.length) {
            
            if (fast < temperatures.length && temperatures[fast] > temperatures[slow]) {
                answer[slow] = fast - slow;
                slow++;
                fast = slow + 1;
            } else {
                fast++;
            }
            if (fast >= temperatures.length) {
                slow++;
                fast = slow + 1;
            }
        }
        return answer;
    }
}

// 单调栈
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> st = new Stack<>(); // 用于存放下标
        int[] answer = new int[temperatures.length];
        st.push(0);
        for (int i = 1; i < temperatures.length; i++) {
            if (temperatures[i] < temperatures[st.peek()]) { // 情况一
                st.push(i);
            } else if (temperatures[i] == temperatures[st.peek()]) { // 情况二
                st.push(i);
            } else {
                while(!st.isEmpty() && temperatures[i] > temperatures[st.peek()]) { // 情况三
                    int index = st.pop();
                    answer[index] = i - index;
                }
                st.push(i);
            }
        }
        return answer;
    }
}

// 精简版
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> st = new Stack<>(); // 用于存放下标
        int[] answer = new int[temperatures.length];
        st.push(0);
        for (int i = 1; i < temperatures.length; i++) {
                while(!st.isEmpty() && temperatures[i] > temperatures[st.peek()]) { // 情况三
                    int index = st.pop();
                    answer[index] = i - index;
                }
                st.push(i);
        }
        return answer;
    }
}
```



### 11.2 下一个更大元素 

[496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] answer = new int[nums1.length];
        Stack<Integer> stack = new Stack<>();
        Arrays.fill(answer, - 1);
        HashMap<Integer, Integer> map = new HashMap<>(); // 映射，用来定位nums1中相同元素的位置（与nums2）
        for (int i = 0; i < nums1.length; i++) {
            map.put(nums1[i], i);
        }
        stack.push(0);
        for (int i = 1; i < nums2.length; i++) {
            if (nums2[stack.peek()] >= nums2[i]) {
                stack.push(i);
            } else {
                while(!stack.isEmpty() && nums2[stack.peek()] < nums2[i]) {
                    if (map.containsKey(nums2[stack.peek()])) {
                        int index = map.get(nums2[stack.peek()]);
                        answer[index] = nums2[i];
                    }
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return answer;
    }
}
```



### 11.3 下一个更大元素 II

[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[nums.length];
        Arrays.fill(result, -1);
        for (int i = 0; i < nums.length * 2; i++) { // 模拟俩遍遍历相当于一个循环数组，节省了空间
            while(!stack.isEmpty() && nums[stack.peek()] < nums[i % nums.length]) {
                result[stack.peek()] = nums[i % nums.length];
                stack.pop();
            }
            stack.push(i % nums.length);
        }
        return result;
    }
}
```



### 11.4 接雨水

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

```java
class Solution {
    public int trap(int[] height) {
        int sum = 0;
        for (int i = 0; i < height.length; i++) {
            // 第一个柱子和最后一个柱子不接雨水
            if (i==0 || i== height.length - 1) continue;
            
            int rHeight = height[i]; // 记录右边柱子的最高高度
            int lHeight = height[i]; // 记录左边柱子的最高高度
            for (int r = i+1; r < height.length; r++) {
                if (height[r] > rHeight) rHeight = height[r];
            }
            for (int l = i-1; l >= 0; l--) {
                if(height[l] > lHeight) lHeight = height[l];
            }
            int h = Math.min(lHeight, rHeight) - height[i];
            if (h > 0) sum += h;
        }
        return sum;
    }
}
```



## 12、总结

耗时一个多月，代码随想录完成了一刷（二叉树有一些题目，还有零零散散的几道题没有刷），每个章节都过了一遍

这也是第一次坚持刷题了一个多月，感觉变化还是很大的，从最早的排斥，经常做着做着想放弃，到现在就算遇到了

标记为hard的题目我也不会去退缩了，一刷下来不能说知识点全都掌握了，但是已经懂了一些解决问题的方法，不至于下次完全

没有头绪了，一刷没有总结的习惯，都是写出来就切下题了，二刷打算要多去总结，多去优化每题的代码，加油，二刷走起！

![](D:\Typoramd\java学习笔记\photo\屏幕截图 2022-03-26 102720.png)

